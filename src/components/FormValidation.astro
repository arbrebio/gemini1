---
interface Props {
  formId: string;
  rules: Array<{
    field: string;
    required?: boolean;
    type?: 'email' | 'phone' | 'text';
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    message?: string;
  }>;
}

const { formId, rules } = Astro.props;
---

<script define:vars={{ formId, rules }}>
  function initFormValidation() {
    const form = document.getElementById(formId);
    if (!form) return;

    // Validation functions
    const validators = {
      email: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
      phone: (value) => /^[\+]?[0-9\s\-\(\)]{10,}$/.test(value),
      text: (value) => value.trim().length > 0
    };

    function validateField(field, value, rule) {
      const errors = [];

      // Required validation
      if (rule.required && !value.trim()) {
        errors.push(rule.message || `${field} is required`);
        return errors;
      }

      // Skip other validations if field is empty and not required
      if (!value.trim() && !rule.required) {
        return errors;
      }

      // Type validation
      if (rule.type && !validators[rule.type](value)) {
        errors.push(rule.message || `Please enter a valid ${rule.type}`);
      }

      // Length validation
      if (rule.minLength && value.length < rule.minLength) {
        errors.push(`Minimum ${rule.minLength} characters required`);
      }
      if (rule.maxLength && value.length > rule.maxLength) {
        errors.push(`Maximum ${rule.maxLength} characters allowed`);
      }

      // Pattern validation
      if (rule.pattern && !new RegExp(rule.pattern).test(value)) {
        errors.push(rule.message || 'Invalid format');
      }

      return errors;
    }

    function showFieldError(fieldName, message) {
      const field = form.querySelector(`[name="${fieldName}"]`);
      if (!field) return;

      // Remove existing error
      clearFieldError(fieldName);

      // Add error styling
      field.classList.add('border-red-500', 'focus:border-red-500', 'focus:ring-red-500');
      field.classList.remove('border-gray-300', 'focus:border-primary', 'focus:ring-primary');

      // Create error message
      const errorDiv = document.createElement('div');
      errorDiv.className = 'text-red-600 text-sm mt-1';
      errorDiv.textContent = message;
      errorDiv.setAttribute('data-error-for', fieldName);

      field.parentNode.insertBefore(errorDiv, field.nextSibling);
    }

    function clearFieldError(fieldName) {
      const field = form.querySelector(`[name="${fieldName}"]`);
      if (!field) return;

      // Remove error styling
      field.classList.remove('border-red-500', 'focus:border-red-500', 'focus:ring-red-500');
      field.classList.add('border-gray-300', 'focus:border-primary', 'focus:ring-primary');

      // Remove error message
      const errorElement = form.querySelector(`[data-error-for="${fieldName}"]`);
      if (errorElement) {
        errorElement.remove();
      }
    }

    function validateForm() {
      let isValid = true;

      rules.forEach(rule => {
        const field = form.querySelector(`[name="${rule.field}"]`);
        if (!field) return;

        const value = field.value;
        const errors = validateField(rule.field, value, rule);

        if (errors.length > 0) {
          showFieldError(rule.field, errors[0]);
          isValid = false;
        } else {
          clearFieldError(rule.field);
        }
      });

      return isValid;
    }

    // Add real-time validation
    rules.forEach(rule => {
      const field = form.querySelector(`[name="${rule.field}"]`);
      if (field) {
        field.addEventListener('blur', () => {
          const value = field.value;
          const errors = validateField(rule.field, value, rule);
          
          if (errors.length > 0) {
            showFieldError(rule.field, errors[0]);
          } else {
            clearFieldError(rule.field);
          }
        });

        field.addEventListener('input', () => {
          clearFieldError(rule.field);
        });
      }
    });

    // Validate on form submission
    form.addEventListener('submit', (e) => {
      if (!validateForm()) {
        e.preventDefault();
      }
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFormValidation);
  } else {
    initFormValidation();
  }
</script>